<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title></title><meta name="description" content=""><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><style>html,body,canvas{width:100%;height:100%;margin:0;padding:0}</style></head><body> <script>(()=>{const n=document.createElement("canvas");document.body.appendChild(n);const e=n.getContext("webgl");n.width=n.clientWidth,n.height=n.clientHeight;const o=e.createShader(e.VERTEX_SHADER);e.shaderSource(o,"\n                    attribute vec2 position;\n                    varying vec2 vertCoord;\n\n                    void main() {\n                        vertCoord = (position + 1.0) / 2.0;\n                        gl_Position = vec4(position, 0.0, 1.0);\n                    }\n                "),e.compileShader(o);const i=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(i,"\n                    precision highp float;\n\n                    uniform vec2 resolution;\n                    uniform float time;\n                    uniform float scanLineSize;\n                    uniform float scanLineDuration;\n                    uniform float scanLinePower;\n                    uniform float pixelSize;\n                    uniform float noisePower;\n\n                    varying vec2 vertCoord;\n\n                    float rand(vec2 st){\n                        return fract( sin( dot( st, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n                    }\n\n                    void main() {\n                        float scanLineY = (1.0 + scanLineSize) - fract(time / scanLineDuration) * (1.0 + scanLineSize * 2.0);\n                        float t = fract(time / 7001.0);\n                        vec2 coord = floor(gl_FragCoord.xy / pixelSize) * pixelSize;\n\n                        vec2 st = vec2(rand(vec2(coord.x, t)), rand(vec2(t, coord.y)));\n                        vec3 color = vec3(rand(st * t)) * noisePower;\n\n                        float intensity = rand(vec2(t, floor(gl_FragCoord.y / 10.0) * 10.0));\n                        color.rgb *= clamp(intensity, 0.7, 1.1);\n\n                        vec2 pos = gl_FragCoord.xy * resolution.xy;\n                        float distance = abs(pos.y - scanLineY);\n                        if (distance < scanLineSize) {\n                            color.rgb += scanLinePower;\n                        }\n\n                        gl_FragColor = vec4(color, 1.0);\n                    }\n                "),e.compileShader(i);const t=e.createProgram();e.attachShader(t,o),e.attachShader(t,i),e.linkProgram(t),e.useProgram(t);const r=new Float32Array([-1,-1,-1,1,1,1,-1,-1,1,1,1,-1]),a=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,a),e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW);const c=e.getAttribLocation(t,"position");e.enableVertexAttribArray(c),e.vertexAttribPointer(c,2,e.FLOAT,!1,0,0);const s=e.getUniformLocation(t,"resolution"),l=e.getUniformLocation(t,"time"),f={scanLineSize:.1,scanLineDuration:5e3,pixelSize:3,noisePower:.3,scanLinePower:.2},d=requestAnimationFrame.bind(null,(n=>{if(!d.last||n-d.last>=20){e.viewport(0,0,e.drawingBufferWidth,e.drawingBufferHeight),e.clearColor(0,0,0,1),e.clear(e.COLOR_BUFFER_BIT),e.uniform2fv(s,[1/e.drawingBufferWidth,1/e.drawingBufferHeight]),e.uniform1f(l,n);for(const[n,o]of Object.entries(f)){const i=e.getUniformLocation(t,n);e.uniform1f(i,o)}e.drawArrays(e.TRIANGLES,0,6),d.last=n}d()}));window.addEventListener("resize",(()=>{n.width=n.clientWidth,n.height=n.clientHeight}),{passive:!0}),d()})();</script> <script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-20822639-1","auto"),ga("send","pageview");</script> </body></html>